{"ast":null,"code":"const defaultOptions = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n};\nfunction normalizeDelay(emblaApi, delay) {\n  const scrollSnaps = emblaApi.scrollSnapList();\n  if (typeof delay === 'number') {\n    return scrollSnaps.map(() => delay);\n  }\n  return delay(scrollSnaps, emblaApi);\n}\nfunction getAutoplayRootNode(emblaApi, rootNode) {\n  const emblaRootNode = emblaApi.rootNode();\n  return rootNode && rootNode(emblaRootNode) || emblaRootNode;\n}\nfunction Autoplay() {\n  let userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options;\n  let emblaApi;\n  let destroyed;\n  let delay;\n  let timerStartTime = null;\n  let timerId = 0;\n  let autoplayActive = false;\n  let mouseIsOver = false;\n  let playOnDocumentVisible = false;\n  let jump = false;\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    if (emblaApi.scrollSnapList().length <= 1) return;\n    jump = options.jump;\n    destroyed = false;\n    delay = normalizeDelay(emblaApi, options.delay);\n    const {\n      eventStore,\n      ownerDocument\n    } = emblaApi.internalEngine();\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag;\n    const root = getAutoplayRootNode(emblaApi, options.rootNode);\n    eventStore.add(ownerDocument, 'visibilitychange', visibilityChange);\n    if (isDraggable) {\n      emblaApi.on('pointerDown', pointerDown);\n    }\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on('pointerUp', pointerUp);\n    }\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', mouseEnter);\n    }\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, 'mouseleave', mouseLeave);\n    }\n    if (options.stopOnFocusIn) {\n      emblaApi.on('slideFocusStart', stopAutoplay);\n    }\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), 'focusout', startAutoplay);\n    }\n    if (options.playOnInit) startAutoplay();\n  }\n  function destroy() {\n    emblaApi.off('pointerDown', pointerDown).off('pointerUp', pointerUp).off('slideFocusStart', stopAutoplay);\n    stopAutoplay();\n    destroyed = true;\n    autoplayActive = false;\n  }\n  function setTimer() {\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearTimeout(timerId);\n    timerId = ownerWindow.setTimeout(next, delay[emblaApi.selectedScrollSnap()]);\n    timerStartTime = new Date().getTime();\n    emblaApi.emit('autoplay:timerset');\n  }\n  function clearTimer() {\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearTimeout(timerId);\n    timerId = 0;\n    timerStartTime = null;\n    emblaApi.emit('autoplay:timerstopped');\n  }\n  function startAutoplay() {\n    if (destroyed) return;\n    if (documentIsHidden()) {\n      playOnDocumentVisible = true;\n      return;\n    }\n    if (!autoplayActive) emblaApi.emit('autoplay:play');\n    setTimer();\n    autoplayActive = true;\n  }\n  function stopAutoplay() {\n    if (destroyed) return;\n    if (autoplayActive) emblaApi.emit('autoplay:stop');\n    clearTimer();\n    autoplayActive = false;\n  }\n  function visibilityChange() {\n    if (documentIsHidden()) {\n      playOnDocumentVisible = autoplayActive;\n      return stopAutoplay();\n    }\n    if (playOnDocumentVisible) startAutoplay();\n  }\n  function documentIsHidden() {\n    const {\n      ownerDocument\n    } = emblaApi.internalEngine();\n    return ownerDocument.visibilityState === 'hidden';\n  }\n  function pointerDown() {\n    if (!mouseIsOver) stopAutoplay();\n  }\n  function pointerUp() {\n    if (!mouseIsOver) startAutoplay();\n  }\n  function mouseEnter() {\n    mouseIsOver = true;\n    stopAutoplay();\n  }\n  function mouseLeave() {\n    mouseIsOver = false;\n    startAutoplay();\n  }\n  function play(jumpOverride) {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride;\n    startAutoplay();\n  }\n  function stop() {\n    if (autoplayActive) stopAutoplay();\n  }\n  function reset() {\n    if (autoplayActive) startAutoplay();\n  }\n  function isPlaying() {\n    return autoplayActive;\n  }\n  function next() {\n    const {\n      index\n    } = emblaApi.internalEngine();\n    const nextIndex = index.clone().add(1).get();\n    const lastIndex = emblaApi.scrollSnapList().length - 1;\n    const kill = options.stopOnLastSnap && nextIndex === lastIndex;\n    if (emblaApi.canScrollNext()) {\n      emblaApi.scrollNext(jump);\n    } else {\n      emblaApi.scrollTo(0, jump);\n    }\n    emblaApi.emit('autoplay:select');\n    if (kill) return stopAutoplay();\n    startAutoplay();\n  }\n  function timeUntilNext() {\n    if (!timerStartTime) return null;\n    const currentDelay = delay[emblaApi.selectedScrollSnap()];\n    const timePastSinceStart = new Date().getTime() - timerStartTime;\n    return currentDelay - timePastSinceStart;\n  }\n  const self = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying,\n    timeUntilNext\n  };\n  return self;\n}\nAutoplay.globalOptions = undefined;\nexport { Autoplay as default };","map":{"version":3,"names":["defaultOptions","active","breakpoints","delay","jump","playOnInit","stopOnFocusIn","stopOnInteraction","stopOnMouseEnter","stopOnLastSnap","rootNode","normalizeDelay","emblaApi","scrollSnaps","scrollSnapList","map","getAutoplayRootNode","emblaRootNode","Autoplay","userOptions","arguments","length","undefined","options","destroyed","timerStartTime","timerId","autoplayActive","mouseIsOver","playOnDocumentVisible","init","emblaApiInstance","optionsHandler","mergeOptions","optionsAtMedia","optionsBase","globalOptions","allOptions","eventStore","ownerDocument","internalEngine","isDraggable","watchDrag","root","add","visibilityChange","on","pointerDown","pointerUp","mouseEnter","mouseLeave","stopAutoplay","containerNode","startAutoplay","destroy","off","setTimer","ownerWindow","clearTimeout","setTimeout","next","selectedScrollSnap","Date","getTime","emit","clearTimer","documentIsHidden","visibilityState","play","jumpOverride","stop","reset","isPlaying","index","nextIndex","clone","get","lastIndex","kill","canScrollNext","scrollNext","scrollTo","timeUntilNext","currentDelay","timePastSinceStart","self","name"],"sources":["/Users/sgreloch/Downloads/Flixxer/node_modules/embla-carousel-autoplay/src/components/Options.ts","/Users/sgreloch/Downloads/Flixxer/node_modules/embla-carousel-autoplay/src/components/utils.ts","/Users/sgreloch/Downloads/Flixxer/node_modules/embla-carousel-autoplay/src/components/Autoplay.ts"],"sourcesContent":["import { CreateOptionsType, EmblaCarouselType } from 'embla-carousel'\n\nexport type DelayOptionType =\n  | number\n  | ((scrollSnaps: number[], emblaApi: EmblaCarouselType) => number[])\n\nexport type RootNodeType =\n  | null\n  | ((emblaRoot: HTMLElement) => HTMLElement | null)\n\nexport type OptionsType = CreateOptionsType<{\n  delay: DelayOptionType\n  jump: boolean\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  stopOnLastSnap: boolean\n  rootNode: RootNodeType\n}>\n\nexport const defaultOptions: OptionsType = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n}\n","import { EmblaCarouselType } from 'embla-carousel/components/EmblaCarousel'\nimport { DelayOptionType, RootNodeType } from './Options'\n\nexport function normalizeDelay(\n  emblaApi: EmblaCarouselType,\n  delay: DelayOptionType\n): number[] {\n  const scrollSnaps = emblaApi.scrollSnapList()\n\n  if (typeof delay === 'number') {\n    return scrollSnaps.map(() => delay)\n  }\n  return delay(scrollSnaps, emblaApi)\n}\n\nexport function getAutoplayRootNode(\n  emblaApi: EmblaCarouselType,\n  rootNode: RootNodeType\n): HTMLElement {\n  const emblaRootNode = emblaApi.rootNode()\n  return (rootNode && rootNode(emblaRootNode)) || emblaRootNode\n}\n","import { OptionsType, defaultOptions } from './Options'\nimport { getAutoplayRootNode, normalizeDelay } from './utils'\nimport {\n  CreatePluginType,\n  OptionsHandlerType,\n  EmblaCarouselType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    autoplay: AutoplayType\n  }\n\n  interface EmblaEventListType {\n    autoplayPlay: 'autoplay:play'\n    autoplayStop: 'autoplay:stop'\n    autoplaySelect: 'autoplay:select'\n    autoplayTimerSet: 'autoplay:timerset'\n    autoplayTimerStopped: 'autoplay:timerstopped'\n  }\n}\n\nexport type AutoplayType = CreatePluginType<\n  {\n    play: (jump?: boolean) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n    timeUntilNext: () => number | null\n  },\n  OptionsType\n>\n\nexport type AutoplayOptionsType = AutoplayType['options']\n\nfunction Autoplay(userOptions: AutoplayOptionsType = {}): AutoplayType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let delay: ReturnType<EmblaCarouselType['scrollSnapList']>\n  let timerStartTime: null | number = null\n  let timerId = 0\n  let autoplayActive = false\n  let mouseIsOver = false\n  let playOnDocumentVisible = false\n  let jump = false\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    jump = options.jump\n    destroyed = false\n    delay = normalizeDelay(emblaApi, options.delay)\n\n    const { eventStore, ownerDocument } = emblaApi.internalEngine()\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag\n    const root = getAutoplayRootNode(emblaApi, options.rootNode)\n\n    eventStore.add(ownerDocument, 'visibilitychange', visibilityChange)\n\n    if (isDraggable) {\n      emblaApi.on('pointerDown', pointerDown)\n    }\n\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on('pointerUp', pointerUp)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', mouseEnter)\n    }\n\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, 'mouseleave', mouseLeave)\n    }\n\n    if (options.stopOnFocusIn) {\n      emblaApi.on('slideFocusStart', stopAutoplay)\n    }\n\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), 'focusout', startAutoplay)\n    }\n\n    if (options.playOnInit) startAutoplay()\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('pointerDown', pointerDown)\n      .off('pointerUp', pointerUp)\n      .off('slideFocusStart', stopAutoplay)\n\n    stopAutoplay()\n    destroyed = true\n    autoplayActive = false\n  }\n\n  function setTimer(): void {\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearTimeout(timerId)\n    timerId = ownerWindow.setTimeout(next, delay[emblaApi.selectedScrollSnap()])\n    timerStartTime = new Date().getTime()\n    emblaApi.emit('autoplay:timerset')\n  }\n\n  function clearTimer(): void {\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearTimeout(timerId)\n    timerId = 0\n    timerStartTime = null\n    emblaApi.emit('autoplay:timerstopped')\n  }\n\n  function startAutoplay(): void {\n    if (destroyed) return\n    if (documentIsHidden()) {\n      playOnDocumentVisible = true\n      return\n    }\n    if (!autoplayActive) emblaApi.emit('autoplay:play')\n\n    setTimer()\n    autoplayActive = true\n  }\n\n  function stopAutoplay(): void {\n    if (destroyed) return\n    if (autoplayActive) emblaApi.emit('autoplay:stop')\n\n    clearTimer()\n    autoplayActive = false\n  }\n\n  function visibilityChange(): void {\n    if (documentIsHidden()) {\n      playOnDocumentVisible = autoplayActive\n      return stopAutoplay()\n    }\n\n    if (playOnDocumentVisible) startAutoplay()\n  }\n\n  function documentIsHidden(): boolean {\n    const { ownerDocument } = emblaApi.internalEngine()\n    return ownerDocument.visibilityState === 'hidden'\n  }\n\n  function pointerDown(): void {\n    if (!mouseIsOver) stopAutoplay()\n  }\n\n  function pointerUp(): void {\n    if (!mouseIsOver) startAutoplay()\n  }\n\n  function mouseEnter(): void {\n    mouseIsOver = true\n    stopAutoplay()\n  }\n\n  function mouseLeave(): void {\n    mouseIsOver = false\n    startAutoplay()\n  }\n\n  function play(jumpOverride?: boolean): void {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride\n    startAutoplay()\n  }\n\n  function stop(): void {\n    if (autoplayActive) stopAutoplay()\n  }\n\n  function reset(): void {\n    if (autoplayActive) startAutoplay()\n  }\n\n  function isPlaying(): boolean {\n    return autoplayActive\n  }\n\n  function next(): void {\n    const { index } = emblaApi.internalEngine()\n    const nextIndex = index.clone().add(1).get()\n    const lastIndex = emblaApi.scrollSnapList().length - 1\n    const kill = options.stopOnLastSnap && nextIndex === lastIndex\n\n    if (emblaApi.canScrollNext()) {\n      emblaApi.scrollNext(jump)\n    } else {\n      emblaApi.scrollTo(0, jump)\n    }\n\n    emblaApi.emit('autoplay:select')\n\n    if (kill) return stopAutoplay()\n    startAutoplay()\n  }\n\n  function timeUntilNext(): number | null {\n    if (!timerStartTime) return null\n    const currentDelay = delay[emblaApi.selectedScrollSnap()]\n    const timePastSinceStart = new Date().getTime() - timerStartTime\n    return currentDelay - timePastSinceStart\n  }\n\n  const self: AutoplayType = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying,\n    timeUntilNext\n  }\n  return self\n}\n\ndeclare namespace Autoplay {\n  let globalOptions: AutoplayOptionsType | undefined\n}\n\nAutoplay.globalOptions = undefined\n\nexport default Autoplay\n"],"mappings":"AAqBO,MAAMA,cAAc,GAAgB;EACzCC,MAAM,EAAE,IAAI;EACZC,WAAW,EAAE,EAAE;EACfC,KAAK,EAAE,IAAI;EACXC,IAAI,EAAE,KAAK;EACXC,UAAU,EAAE,IAAI;EAChBC,aAAa,EAAE,IAAI;EACnBC,iBAAiB,EAAE,IAAI;EACvBC,gBAAgB,EAAE,KAAK;EACvBC,cAAc,EAAE,KAAK;EACrBC,QAAQ,EAAE;CACX;AC7Be,SAAAC,cAAcA,CAC5BC,QAA2B,EAC3BT,KAAsB;EAEtB,MAAMU,WAAW,GAAGD,QAAQ,CAACE,cAAc,EAAE;EAE7C,IAAI,OAAOX,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOU,WAAW,CAACE,GAAG,CAAC,MAAMZ,KAAK,CAAC;EACrC;EACA,OAAOA,KAAK,CAACU,WAAW,EAAED,QAAQ,CAAC;AACrC;AAEgB,SAAAI,mBAAmBA,CACjCJ,QAA2B,EAC3BF,QAAsB;EAEtB,MAAMO,aAAa,GAAGL,QAAQ,CAACF,QAAQ,EAAE;EACzC,OAAQA,QAAQ,IAAIA,QAAQ,CAACO,aAAa,CAAC,IAAKA,aAAa;AAC/D;ACcA,SAASC,QAAQA,CAAA,EAAsC;EAAA,IAArCC,WAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmC,EAAE;EACrD,IAAIG,OAAoB;EACxB,IAAIX,QAA2B;EAC/B,IAAIY,SAAkB;EACtB,IAAIrB,KAAsD;EAC1D,IAAIsB,cAAc,GAAkB,IAAI;EACxC,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,cAAc,GAAG,KAAK;EAC1B,IAAIC,WAAW,GAAG,KAAK;EACvB,IAAIC,qBAAqB,GAAG,KAAK;EACjC,IAAIzB,IAAI,GAAG,KAAK;EAEhB,SAAS0B,IAAIA,CACXC,gBAAmC,EACnCC,cAAkC;IAElCpB,QAAQ,GAAGmB,gBAAgB;IAE3B,MAAM;MAAEE,YAAY;MAAEC;IAAgB,IAAGF,cAAc;IACvD,MAAMG,WAAW,GAAGF,YAAY,CAACjC,cAAc,EAAEkB,QAAQ,CAACkB,aAAa,CAAC;IACxE,MAAMC,UAAU,GAAGJ,YAAY,CAACE,WAAW,EAAEhB,WAAW,CAAC;IACzDI,OAAO,GAAGW,cAAc,CAACG,UAAU,CAAC;IAEpC,IAAIzB,QAAQ,CAACE,cAAc,EAAE,CAACO,MAAM,IAAI,CAAC,EAAE;IAE3CjB,IAAI,GAAGmB,OAAO,CAACnB,IAAI;IACnBoB,SAAS,GAAG,KAAK;IACjBrB,KAAK,GAAGQ,cAAc,CAACC,QAAQ,EAAEW,OAAO,CAACpB,KAAK,CAAC;IAE/C,MAAM;MAAEmC,UAAU;MAAEC;IAAa,CAAE,GAAG3B,QAAQ,CAAC4B,cAAc,EAAE;IAC/D,MAAMC,WAAW,GAAG,CAAC,CAAC7B,QAAQ,CAAC4B,cAAc,EAAE,CAACjB,OAAO,CAACmB,SAAS;IACjE,MAAMC,IAAI,GAAG3B,mBAAmB,CAACJ,QAAQ,EAAEW,OAAO,CAACb,QAAQ,CAAC;IAE5D4B,UAAU,CAACM,GAAG,CAACL,aAAa,EAAE,kBAAkB,EAAEM,gBAAgB,CAAC;IAEnE,IAAIJ,WAAW,EAAE;MACf7B,QAAQ,CAACkC,EAAE,CAAC,aAAa,EAAEC,WAAW,CAAC;IACzC;IAEA,IAAIN,WAAW,IAAI,CAAClB,OAAO,CAAChB,iBAAiB,EAAE;MAC7CK,QAAQ,CAACkC,EAAE,CAAC,WAAW,EAAEE,SAAS,CAAC;IACrC;IAEA,IAAIzB,OAAO,CAACf,gBAAgB,EAAE;MAC5B8B,UAAU,CAACM,GAAG,CAACD,IAAI,EAAE,YAAY,EAAEM,UAAU,CAAC;IAChD;IAEA,IAAI1B,OAAO,CAACf,gBAAgB,IAAI,CAACe,OAAO,CAAChB,iBAAiB,EAAE;MAC1D+B,UAAU,CAACM,GAAG,CAACD,IAAI,EAAE,YAAY,EAAEO,UAAU,CAAC;IAChD;IAEA,IAAI3B,OAAO,CAACjB,aAAa,EAAE;MACzBM,QAAQ,CAACkC,EAAE,CAAC,iBAAiB,EAAEK,YAAY,CAAC;IAC9C;IAEA,IAAI5B,OAAO,CAACjB,aAAa,IAAI,CAACiB,OAAO,CAAChB,iBAAiB,EAAE;MACvD+B,UAAU,CAACM,GAAG,CAAChC,QAAQ,CAACwC,aAAa,EAAE,EAAE,UAAU,EAAEC,aAAa,CAAC;IACrE;IAEA,IAAI9B,OAAO,CAAClB,UAAU,EAAEgD,aAAa,EAAE;EACzC;EAEA,SAASC,OAAOA,CAAA;IACd1C,QAAQ,CACL2C,GAAG,CAAC,aAAa,EAAER,WAAW,CAAC,CAC/BQ,GAAG,CAAC,WAAW,EAAEP,SAAS,CAAC,CAC3BO,GAAG,CAAC,iBAAiB,EAAEJ,YAAY,CAAC;IAEvCA,YAAY,EAAE;IACd3B,SAAS,GAAG,IAAI;IAChBG,cAAc,GAAG,KAAK;EACxB;EAEA,SAAS6B,QAAQA,CAAA;IACf,MAAM;MAAEC;IAAa,IAAG7C,QAAQ,CAAC4B,cAAc,EAAE;IACjDiB,WAAW,CAACC,YAAY,CAAChC,OAAO,CAAC;IACjCA,OAAO,GAAG+B,WAAW,CAACE,UAAU,CAACC,IAAI,EAAEzD,KAAK,CAACS,QAAQ,CAACiD,kBAAkB,EAAE,CAAC,CAAC;IAC5EpC,cAAc,GAAG,IAAIqC,IAAI,EAAE,CAACC,OAAO,EAAE;IACrCnD,QAAQ,CAACoD,IAAI,CAAC,mBAAmB,CAAC;EACpC;EAEA,SAASC,UAAUA,CAAA;IACjB,MAAM;MAAER;IAAa,IAAG7C,QAAQ,CAAC4B,cAAc,EAAE;IACjDiB,WAAW,CAACC,YAAY,CAAChC,OAAO,CAAC;IACjCA,OAAO,GAAG,CAAC;IACXD,cAAc,GAAG,IAAI;IACrBb,QAAQ,CAACoD,IAAI,CAAC,uBAAuB,CAAC;EACxC;EAEA,SAASX,aAAaA,CAAA;IACpB,IAAI7B,SAAS,EAAE;IACf,IAAI0C,gBAAgB,EAAE,EAAE;MACtBrC,qBAAqB,GAAG,IAAI;MAC5B;IACF;IACA,IAAI,CAACF,cAAc,EAAEf,QAAQ,CAACoD,IAAI,CAAC,eAAe,CAAC;IAEnDR,QAAQ,EAAE;IACV7B,cAAc,GAAG,IAAI;EACvB;EAEA,SAASwB,YAAYA,CAAA;IACnB,IAAI3B,SAAS,EAAE;IACf,IAAIG,cAAc,EAAEf,QAAQ,CAACoD,IAAI,CAAC,eAAe,CAAC;IAElDC,UAAU,EAAE;IACZtC,cAAc,GAAG,KAAK;EACxB;EAEA,SAASkB,gBAAgBA,CAAA;IACvB,IAAIqB,gBAAgB,EAAE,EAAE;MACtBrC,qBAAqB,GAAGF,cAAc;MACtC,OAAOwB,YAAY,EAAE;IACvB;IAEA,IAAItB,qBAAqB,EAAEwB,aAAa,EAAE;EAC5C;EAEA,SAASa,gBAAgBA,CAAA;IACvB,MAAM;MAAE3B;IAAe,IAAG3B,QAAQ,CAAC4B,cAAc,EAAE;IACnD,OAAOD,aAAa,CAAC4B,eAAe,KAAK,QAAQ;EACnD;EAEA,SAASpB,WAAWA,CAAA;IAClB,IAAI,CAACnB,WAAW,EAAEuB,YAAY,EAAE;EAClC;EAEA,SAASH,SAASA,CAAA;IAChB,IAAI,CAACpB,WAAW,EAAEyB,aAAa,EAAE;EACnC;EAEA,SAASJ,UAAUA,CAAA;IACjBrB,WAAW,GAAG,IAAI;IAClBuB,YAAY,EAAE;EAChB;EAEA,SAASD,UAAUA,CAAA;IACjBtB,WAAW,GAAG,KAAK;IACnByB,aAAa,EAAE;EACjB;EAEA,SAASe,IAAIA,CAACC,YAAsB;IAClC,IAAI,OAAOA,YAAY,KAAK,WAAW,EAAEjE,IAAI,GAAGiE,YAAY;IAC5DhB,aAAa,EAAE;EACjB;EAEA,SAASiB,IAAIA,CAAA;IACX,IAAI3C,cAAc,EAAEwB,YAAY,EAAE;EACpC;EAEA,SAASoB,KAAKA,CAAA;IACZ,IAAI5C,cAAc,EAAE0B,aAAa,EAAE;EACrC;EAEA,SAASmB,SAASA,CAAA;IAChB,OAAO7C,cAAc;EACvB;EAEA,SAASiC,IAAIA,CAAA;IACX,MAAM;MAAEa;IAAO,IAAG7D,QAAQ,CAAC4B,cAAc,EAAE;IAC3C,MAAMkC,SAAS,GAAGD,KAAK,CAACE,KAAK,EAAE,CAAC/B,GAAG,CAAC,CAAC,CAAC,CAACgC,GAAG,EAAE;IAC5C,MAAMC,SAAS,GAAGjE,QAAQ,CAACE,cAAc,EAAE,CAACO,MAAM,GAAG,CAAC;IACtD,MAAMyD,IAAI,GAAGvD,OAAO,CAACd,cAAc,IAAIiE,SAAS,KAAKG,SAAS;IAE9D,IAAIjE,QAAQ,CAACmE,aAAa,EAAE,EAAE;MAC5BnE,QAAQ,CAACoE,UAAU,CAAC5E,IAAI,CAAC;IAC3B,CAAC,MAAM;MACLQ,QAAQ,CAACqE,QAAQ,CAAC,CAAC,EAAE7E,IAAI,CAAC;IAC5B;IAEAQ,QAAQ,CAACoD,IAAI,CAAC,iBAAiB,CAAC;IAEhC,IAAIc,IAAI,EAAE,OAAO3B,YAAY,EAAE;IAC/BE,aAAa,EAAE;EACjB;EAEA,SAAS6B,aAAaA,CAAA;IACpB,IAAI,CAACzD,cAAc,EAAE,OAAO,IAAI;IAChC,MAAM0D,YAAY,GAAGhF,KAAK,CAACS,QAAQ,CAACiD,kBAAkB,EAAE,CAAC;IACzD,MAAMuB,kBAAkB,GAAG,IAAItB,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGtC,cAAc;IAChE,OAAO0D,YAAY,GAAGC,kBAAkB;EAC1C;EAEA,MAAMC,IAAI,GAAiB;IACzBC,IAAI,EAAE,UAAU;IAChB/D,OAAO,EAAEJ,WAAW;IACpBW,IAAI;IACJwB,OAAO;IACPc,IAAI;IACJE,IAAI;IACJC,KAAK;IACLC,SAAS;IACTU;GACD;EACD,OAAOG,IAAI;AACb;AAMAnE,QAAQ,CAACkB,aAAa,GAAGd,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}